import time
import random
import math
import requests
import json
import os
from datetime import datetime

# --- CONFIGURATION ---
GATEWAY_URL = "http://localhost:3000/api/v1/market/ingest"
WORKER_ID = "SCRAPER-PY-01"
SESSION_FILE = "active_session.json"

# CIBLE (Exemple: Vinicius Jr)
TARGET_CONFIG = {
    "player_id": "239085",
    "max_buy_price": 150000, # On achète tout ce qui est en dessous
    "sell_price": 165000     # Pour calcul de profit théorique
}

# --- MOTEUR D'HUMANISATION ---
def human_sleep(base_ms, variance_ms):
    jitter = random.gauss(0, variance_ms)
    delay = max(500, base_ms + jitter) # Min 500ms
    time.sleep(delay / 1000.0)

class MarketWorker:
    def __init__(self):
        self.session = requests.Session()
        self.load_session()

    def load_session(self):
        """Charge les identifiants volés par le browser"""
        if not os.path.exists(SESSION_FILE):
            raise FileNotFoundError(f"[STOP] Fichier {SESSION_FILE} introuvable. Lancez auth_manager.py d'abord.")
        
        with open(SESSION_FILE, 'r') as f:
            data = json.load(f)
            
        self.auth_data = data
        # Configuration des Headers EA officiels
        self.session.headers.update({
            "User-Agent": data.get("user_agent", "Mozilla/5.0"),
            "Accept": "application/json",
            "X-UT-SID": data.get("x-ut-sid"), # Le token critique
            "Connection": "keep-alive",
            "Content-Type": "application/json"
        })
        print(f"[INIT] Session chargée. Token: {data.get('x-ut-sid')[:10]}...")

    def search_market(self):
        """
        Scan le marché. 
        Retourne: (price, trade_id, latency)
        """
        # 1. Human delay avant action
        human_sleep(1200, 300) 
        start_time = time.time()
        
        # 2. Simulation Appel API EA (GET /transfermarket)
        # Dans le vrai code, c'est ici qu'on met l'URL officielle EA avec les params de recherche
        # Pour l'instant, on simule une réponse de l'API
        
        # Simule une trouvaille aléatoire
        found_price = random.randint(140000, 160000) 
        trade_id = str(random.randint(1000000000, 9999999999)) # ID unique de la carte requis pour acheter
        
        latency = int((time.time() - start_time) * 1000)
        
        # 3. Temps de réaction visuelle
        human_sleep(600, 150)

        return found_price, trade_id, latency

    def execute_bid(self, trade_id, price):
        """
        Envoie l'ordre d'achat (PUT)
        """
        print(f"[>>>] TENTATIVE D'ACHAT: {price} cr (Trade ID: {trade_id})")
        
        # URL officielle pour placer une enchère/achat immédiat
        url = f"https://ut-market.ea.com/ut/game/fifa24/trade/{trade_id}/bid"
        payload = {"bid": price}
        
        # Headers spécifiques à l'action d'achat (Crucial pour éviter le ban)
        headers_override = {
            "X-HTTP-Method-Override": "PUT",
            "Referer": "https://www.ea.com/",
            "Origin": "https://www.ea.com"
        }
        
        try:
            # On merge les headers de session avec les headers spécifiques
            resp = self.session.put(url, json=payload, headers=headers_override, timeout=2)
            
            latency = resp.elapsed.total_seconds() * 1000
            
            if resp.status_code == 200:
                print(f"[$$$] SUCCÈS ! Carte achetée en {latency:.0f}ms")
                return True
            
            # Codes d'erreur fréquents EA
            elif resp.status_code == 461:
                print(f"[FAIL] Déjà vendue (Outbid) - {latency:.0f}ms")
            elif resp.status_code == 429:
                print(f"[ALERT] Trop de requêtes (429) - Pause forcée")
                human_sleep(10000, 0)
            else:
                print(f"[ERR] Code API EA inconnu: {resp.status_code}")
                
        except Exception as e:
            print(f"[CRASH] Erreur réseau lors de l'achat: {e}")
            
        return False

    def report_to_gateway(self, price, latency):
        """Envoie les stats au Dashboard (Go/React)"""
        try:
            payload = {
                "worker_id": WORKER_ID,
                "player_id": TARGET_CONFIG["player_id"],
                "price": price,
                "timestamp": int(time.time()),
                "duration_ms": latency
            }
            requests.post(GATEWAY_URL, json=payload, timeout=0.1)
        except:
            pass # On s'en fiche si le dashboard est down, le trading continue

    def run(self):
        print(f"[START] Worker démarré sur cible {TARGET_CONFIG['player_id']}")
        consecutive_errors = 0
        
        while True:
            try:
                # A. SCAN
                price, trade_id, latency = self.search_market()
                
                # B. DECISION (Logique de Trading)
                is_buy_signal = price <= TARGET_CONFIG["max_buy_price"]
                
                print(f"[SCAN] Vu à {price} | Latence: {latency}ms | {'ACHAT!' if is_buy_signal else 'Ignoré'}")
                
                # C. EXECUTION
                if is_buy_signal:
                    self.execute_bid(trade_id, price)
                
                # D. REPORTING
                self.report_to_gateway(price, latency)
                
                consecutive_errors = 0
                
                # E. COOLDOWN (Anti-Bot)
                human_sleep(4500, 1000)

            except Exception as e:
                consecutive_errors += 1
                print(f"[ERR] Erreur boucle principale: {e}")
                if consecutive_errors > 5:
                    print("[STOP] Trop d'erreurs, arrêt d'urgence.")
                    break
                human_sleep(5000, 0)

if __name__ == "__main__":
    bot = MarketWorker()
    bot.run()